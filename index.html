<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>‡∏Ç‡∏µ‡∏î‡πÄ‡∏™‡πâ‡∏ô PDF ‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ (‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á)</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
      overscroll-behavior: contain;
      box-sizing: border-box;
    }
    .pdf-container {
      width: 100%;
      max-width: 900px;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 15px;
    }
    .pdf-page-wrap {
      margin-bottom: 20px;
      position: relative;
    }
    canvas {
      border: 1px solid #888;
      display: block;
      background: white;
      max-width: 100vw;
      height: auto;
      touch-action: none;
      user-select: none;
    }
    .controls-fixed {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      z-index: 999;
      background: rgba(255,255,255,0.98);
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      padding: 8px 0 8px 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      border-bottom: 1px solid #eee;
      max-width: 100vw;
    }
    .controls-fixed button {
      font-size: 18px;
      padding: 12px 20px;
      border-radius: 6px;
      border: 1px solid #333;
      background: #f0f0f0;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      flex-grow: 1;
      min-width: 120px;
      transition: background-color 0.3s;
    }
    .controls-fixed button.active {
      background-color: #4caf50;
      color: white;
      border-color: #3e8e41;
    }
    .controls-fixed button:active:not(.active) {
      background: #ddd;
    }
    input[type="file"] {
      font-size: 18px;
      margin-bottom: 10px;
      max-width: 100%;
      margin-top: 10px;
    }
    /* ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ scroll ‡πÑ‡∏°‡πà‡πÇ‡∏î‡∏ô‡∏õ‡∏¥‡∏î‡∏´‡∏±‡∏ß */
    .controls-spacer {
      height: 76px;
      width: 100%;
      max-width: 900px;
    }
    @media (max-width: 600px) {
      .controls-fixed {
        flex-direction: column;
        gap: 6px;
        padding: 6px 0 6px 0;
      }
      .controls-spacer {
        height: 108px;
      }
    }
  </style>
</head>
<body>
  <h2>‡∏Ç‡∏µ‡∏î‡πÄ‡∏™‡πâ‡∏ô PDF ‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤ (‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á) - ‡∏•‡∏≤‡∏Å‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏î‡πâ ‡πÄ‡∏•‡∏Ç index ‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á</h2>
  <input type="file" id="pdf-upload" accept="application/pdf" />
  <div class="controls-fixed">
    <button id="btn-draw" class="active">üñäÔ∏è ‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏™‡πâ‡∏ô</button>
    <button id="btn-pan">‚úã ‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô/‡∏ã‡∏π‡∏°</button>
    <button id="btn-undo">‚Ü©Ô∏è ‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)</button>
    <button id="btn-save">üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô PDF</button>
  </div>
  <div class="controls-spacer"></div>
  <div id="pdf-container" class="pdf-container"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    const input = document.getElementById('pdf-upload');
    const pdfContainer = document.getElementById('pdf-container');
    const btnDraw = document.getElementById('btn-draw');
    const btnPan = document.getElementById('btn-pan');
    const btnUndo = document.getElementById('btn-undo');
    const btnSave = document.getElementById('btn-save');

    let pdfDoc = null;
    let totalPages = 0;
    let pdfFingerprint = null;
    let mode = 'draw'; // 'draw' ‡∏´‡∏£‡∏∑‡∏≠ 'pan'

    let lines = {};
    let canvases = [];
    let pageStates = []; // [{offsetX, offsetY, scale, isDrawing, startX, startY, isPanning, panStartX, panStartY, lastDist}]

    function getNextLineIndex(page) {
      let index = 0;
      for (let i = 1; i < page; i++) {
        index += (lines[i]?.length || 0);
      }
      index += (lines[page]?.length || 0);
      return index + 1;
    }

    function saveLinesToStorage() {
      if (!pdfFingerprint) return;
      localStorage.setItem(`pdfLines_${pdfFingerprint}`, JSON.stringify({lines}));
    }
    function loadLinesFromStorage() {
      if (!pdfFingerprint) return;
      const data = localStorage.getItem(`pdfLines_${pdfFingerprint}`);
      if (data) {
        try {
          const obj = JSON.parse(data);
          lines = obj.lines || {};
        } catch { lines = {}; }
      }
    }

    input.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const fileReader = new FileReader();
      fileReader.onload = async function () {
        const typedArray = new Uint8Array(this.result);
        pdfDoc = await pdfjsLib.getDocument({ data: typedArray }).promise;
        totalPages = pdfDoc.numPages;
        pdfFingerprint = pdfDoc.fingerprints ? pdfDoc.fingerprints[0] : null;
        loadLinesFromStorage();

        pdfContainer.innerHTML = "";
        canvases = [];
        pageStates = [];

        // render ‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤
        for (let i = 1; i <= totalPages; i++) {
          lines[i] = lines[i] || [];
          await renderPage(i);
        }
      };
      fileReader.readAsArrayBuffer(file);
    });

    async function renderPage(pageNum) {
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale: 2 });
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = viewport.width;
      tempCanvas.height = viewport.height;
      const tempCtx = tempCanvas.getContext('2d');
      await page.render({ canvasContext: tempCtx, viewport }).promise;

      // ‡∏™‡∏£‡πâ‡∏≤‡∏á image ‡∏à‡∏≤‡∏Å canvas ‡∏ô‡∏µ‡πâ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡∏ß‡∏≤‡∏î‡∏ã‡πâ‡∏≥
      const pdfPageImage = new Image();
      pdfPageImage.src = tempCanvas.toDataURL();

      pdfPageImage.onload = () => {
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á canvas ‡∏à‡∏£‡∏¥‡∏á
        const wrap = document.createElement('div');
        wrap.className = 'pdf-page-wrap';
        const canvas = document.createElement('canvas');
        canvas.width = pdfPageImage.width;
        canvas.height = pdfPageImage.height;
        wrap.appendChild(canvas);
        pdfContainer.appendChild(wrap);

        canvases[pageNum] = canvas;
        pageStates[pageNum] = {
          offsetX: 0, offsetY: 0, scale: Math.min(1, window.innerWidth/pdfPageImage.width), isDrawing: false,
          isPanning: false, panStartX: 0, panStartY: 0, lastDist: null,
          startX: 0, startY: 0, img: pdfPageImage
        };

        drawCurrentView(pageNum);

        // Event - Draw Mode
        canvas.addEventListener('mousedown', e => {
          if (mode !== 'draw') return;
          pageStates[pageNum].isDrawing = true;
          const pos = getEventPos(e, pageNum);
          pageStates[pageNum].startX = pos.x;
          pageStates[pageNum].startY = pos.y;
        });
        canvas.addEventListener('mouseup', e => {
          if (mode !== 'draw' || !pageStates[pageNum].isDrawing) return;
          pageStates[pageNum].isDrawing = false;
          const pos = getEventPos(e, pageNum);
          const endX = pos.x, endY = pos.y;
          const lineIndex = getNextLineIndex(pageNum);
          lines[pageNum].push({startX: pageStates[pageNum].startX, startY: pageStates[pageNum].startY, endX, endY, index: lineIndex});
          saveLinesToStorage();
          drawCurrentView(pageNum);
        });
        canvas.addEventListener('mouseleave', e => {
          if (mode !== 'draw') return;
          pageStates[pageNum].isDrawing = false;
        });
        canvas.addEventListener('touchstart', e => {
          if (mode !== 'draw') return;
          e.preventDefault();
          pageStates[pageNum].isDrawing = true;
          const pos = getEventPos(e, pageNum);
          pageStates[pageNum].startX = pos.x;
          pageStates[pageNum].startY = pos.y;
        }, { passive: false });
        canvas.addEventListener('touchend', e => {
          if (mode !== 'draw') return;
          e.preventDefault();
          if (!pageStates[pageNum].isDrawing) return;
          pageStates[pageNum].isDrawing = false;
          const pos = getEventPos(e, pageNum);
          const endX = pos.x, endY = pos.y;
          const lineIndex = getNextLineIndex(pageNum);
          lines[pageNum].push({startX: pageStates[pageNum].startX, startY: pageStates[pageNum].startY, endX, endY, index: lineIndex});
          saveLinesToStorage();
          drawCurrentView(pageNum);
        }, { passive: false });

        // Pan/Zoom
        canvas.addEventListener('touchstart', e => {
          if (mode !== 'pan') return;
          if (e.touches.length === 1) {
            pageStates[pageNum].isPanning = true;
            pageStates[pageNum].panStartX = e.touches[0].clientX;
            pageStates[pageNum].panStartY = e.touches[0].clientY;
          } else {
            pageStates[pageNum].isPanning = false;
          }
          pageStates[pageNum].lastDist = null;
        });
        canvas.addEventListener('touchmove', e => {
          if (mode !== 'pan') return;
          e.preventDefault();
          const touches = e.touches;
          if (touches.length === 1 && pageStates[pageNum].isPanning) {
            const dx = touches[0].clientX - pageStates[pageNum].panStartX;
            const dy = touches[0].clientY - pageStates[pageNum].panStartY;
            pageStates[pageNum].panStartX = touches[0].clientX;
            pageStates[pageNum].panStartY = touches[0].clientY;
            pageStates[pageNum].offsetX += dx;
            pageStates[pageNum].offsetY += dy;
            clampOffsets(pageNum);
            drawCurrentView(pageNum);
          } else if (touches.length === 2) {
            const dist = getDistance(touches);
            if (pageStates[pageNum].lastDist) {
              let zoom = dist / pageStates[pageNum].lastDist;
              let newScale = pageStates[pageNum].scale * zoom;
              newScale = Math.min(Math.max(newScale, 0.5), 5);
              // ‡∏ã‡∏π‡∏°‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
              const rect = canvas.getBoundingClientRect();
              const centerX = (touches[0].clientX + touches[1].clientX) / 2 - rect.left;
              const centerY = (touches[0].clientY + touches[1].clientY) / 2 - rect.top;
              pageStates[pageNum].offsetX = centerX - ((centerX - pageStates[pageNum].offsetX) * (newScale / pageStates[pageNum].scale));
              pageStates[pageNum].offsetY = centerY - ((centerY - pageStates[pageNum].offsetY) * (newScale / pageStates[pageNum].scale));
              pageStates[pageNum].scale = newScale;
              clampOffsets(pageNum);
              drawCurrentView(pageNum);
            }
            pageStates[pageNum].lastDist = dist;
          }
        }, { passive: false });
        canvas.addEventListener('touchend', e => {
          if (mode !== 'pan') return;
          if (e.touches.length === 0) pageStates[pageNum].isPanning = false;
          pageStates[pageNum].lastDist = null;
        });
      };
    }

    function getEventPos(evt, pageNum) {
      const rect = canvases[pageNum].getBoundingClientRect();
      let clientX, clientY;
      if (evt.touches && evt.touches.length > 0) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else if (evt.changedTouches && evt.changedTouches.length > 0) {
        clientX = evt.changedTouches[0].clientX;
        clientY = evt.changedTouches[0].clientY;
      } else {
        clientX = evt.clientX || evt.offsetX;
        clientY = evt.clientY || evt.offsetY;
      }
      return {
        x: (clientX - rect.left - pageStates[pageNum].offsetX) / pageStates[pageNum].scale,
        y: (clientY - rect.top - pageStates[pageNum].offsetY) / pageStates[pageNum].scale
      };
    }
    function getDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function clampOffsets(pageNum) {
      const canvas = canvases[pageNum];
      const img = pageStates[pageNum].img;
      const maxOffsetX = 0, maxOffsetY = 0;
      const imgWidthScaled = img.width * pageStates[pageNum].scale;
      const imgHeightScaled = img.height * pageStates[pageNum].scale;
      const minOffsetX = canvas.width - imgWidthScaled;
      const minOffsetY = canvas.height - imgHeightScaled;
      if (minOffsetX >= maxOffsetX) {
        pageStates[pageNum].offsetX = (canvas.width - imgWidthScaled) / 2;
      } else {
        pageStates[pageNum].offsetX = Math.min(maxOffsetX, Math.max(minOffsetX, pageStates[pageNum].offsetX));
      }
      if (minOffsetY >= maxOffsetY) {
        pageStates[pageNum].offsetY = (canvas.height - imgHeightScaled) / 2;
      } else {
        pageStates[pageNum].offsetY = Math.min(maxOffsetY, Math.max(minOffsetY, pageStates[pageNum].offsetY));
      }
    }
    function drawCurrentView(pageNum) {
      const canvas = canvases[pageNum];
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const img = pageStates[pageNum].img;
      clampOffsets(pageNum);

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.setTransform(pageStates[pageNum].scale, 0, 0, pageStates[pageNum].scale, pageStates[pageNum].offsetX, pageStates[pageNum].offsetY);
      ctx.drawImage(img, 0, 0);

      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2 / pageStates[pageNum].scale;
      ctx.font = `${18 / pageStates[pageNum].scale}px sans-serif`;
      ctx.fillStyle = 'blue';
      for (let line of lines[pageNum] || []) {
        ctx.beginPath();
        ctx.moveTo(line.startX, line.startY);
        ctx.lineTo(line.endX, line.endY);
        ctx.stroke();
        ctx.fillText(line.index, line.endX + 5, line.endY);
      }
    }

    // ---- UI Controls ----
    btnDraw.onclick = () => {
      mode = 'draw';
      btnDraw.classList.add('active');
      btnPan.classList.remove('active');
      canvases.forEach(c => { if (c) c.style.cursor = 'crosshair'; });
    };
    btnPan.onclick = () => {
      mode = 'pan';
      btnDraw.classList.remove('active');
      btnPan.classList.add('active');
      canvases.forEach(c => { if (c) c.style.cursor = 'grab'; });
    };
    btnUndo.onclick = () => {
      // ‡∏•‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÄ‡∏™‡πâ‡∏ô
      for (let i = totalPages; i >= 1; i--) {
        if (lines[i] && lines[i].length > 0) {
          lines[i].pop();
          saveLinesToStorage();
          drawCurrentView(i);
          break;
        }
      }
    };

    btnSave.onclick = async function () {
      if (!pdfDoc) return alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î PDF ‡∏Å‡πà‡∏≠‡∏ô');
      const { jsPDF } = window.jspdf;
      const firstCanvas = canvases[1];
      const pdf = new jsPDF({
        unit: 'pt',
        format: [firstCanvas.width, firstCanvas.height]
      });
      for (let i = 1; i <= totalPages; i++) {
        if (i > 1) pdf.addPage();
        drawCurrentView(i);
        const imgData = canvases[i].toDataURL('image/png');
        pdf.addImage(imgData, 'PNG', 0, 0, firstCanvas.width, firstCanvas.height);
      }
      pdf.save('‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏Ç‡∏µ‡∏î‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß.pdf');
    };

  </script>
</body>
</html>
