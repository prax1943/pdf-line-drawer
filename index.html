<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>Workspace PDF ‡∏ß‡∏≤‡∏î/‡∏ã‡∏π‡∏°/‡πÅ‡∏û‡∏ô‡∏£‡∏ß‡∏°</title>
  <style>
    html,body { margin:0; padding:0; background:#efefef; height:100%; }
    body {
      min-height:100vh;
      display:flex;
      flex-direction:column;
      align-items:center;
      font-family:sans-serif;
    }
    #toolbar {
      margin: 10px 0 8px 0;
      display: flex;
      gap: 14px;
      align-items: center;
    }
    #pdf-upload { font-size: 16px; }
    #save-btn {
      font-size: 1.4rem;
      padding: 7px 18px;
      border-radius: 7px;
      border: 1px solid #888;
      background: #f0f0f0;
      cursor: pointer;
    }
    #pdf-workspace {
      background: #fff;
      border: 1.5px solid #bbb;
      touch-action: none;
      user-select: none;
      display: block;
      margin: 0 auto 30px auto;
      box-shadow:0 4px 20px #0002;
      max-width: 100vw;
      max-height: 90vh;
    }
    #hint {
      font-size: 1rem;
      color: #333;
      margin-top: 0.6em;
    }
    @media (max-width:600px) {
      #pdf-workspace { max-width: 100vw; max-height:60vh;}
      #toolbar { flex-direction: column; gap:6px;}
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="file" id="pdf-upload" accept="application/pdf" />
    <button id="save-btn">üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å PDF</button>
  </div>
  <canvas id="pdf-workspace"></canvas>
  <div id="hint">
    <span>üñäÔ∏è ‡∏ß‡∏≤‡∏î: ‡∏ô‡∏¥‡πâ‡∏ß‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏°‡∏≤‡∏™‡πå | ü§è ‡πÅ‡∏û‡∏ô/‡∏ã‡∏π‡∏°: ‡∏™‡∏≠‡∏á‡∏ô‡∏¥‡πâ‡∏ß (pinch/drag)</span>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script>
    // --- State
    let pdfDoc = null, pdfPages = [], totalPages = 0;
    let lines = []; // {page, startX, startY, endX, endY}
    let pageRects = []; // [{x, y, w, h}]
    let scale = 1, offsetX = 0, offsetY = 0;
    let dragging = false, lastX = 0, lastY = 0;
    let drawing = false, drawStart = {x:0,y:0}, drawPage = null;
    let pinchLastDist = null, pinchLastCenter = null;
    let workspaceW = 800, workspaceH = 1130;
    const canvas = document.getElementById('pdf-workspace');
    const ctx = canvas.getContext('2d');

    // --- PDF Upload & Render
    document.getElementById('pdf-upload').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      pdfDoc = await pdfjsLib.getDocument({data: await file.arrayBuffer()}).promise;
      totalPages = pdfDoc.numPages;
      pdfPages = [];
      pageRects = [];
      lines = [];
      // Render all pages to images, stack vertically
      let y = 0, maxW = 0;
      for(let i=1;i<=totalPages;i++) {
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({scale:2});
        const c = document.createElement('canvas');
        c.width = viewport.width; c.height = viewport.height;
        await page.render({canvasContext:c.getContext('2d'), viewport}).promise;
        pdfPages.push({img: c, w: viewport.width, h: viewport.height});
        pageRects.push({x:0, y, w: viewport.width, h: viewport.height});
        y += viewport.height;
        if(viewport.width>maxW) maxW=viewport.width;
      }
      workspaceW = maxW;
      workspaceH = y;
      scale = Math.min(window.innerWidth / workspaceW, window.innerHeight / workspaceH, 1);
      offsetX = (canvas.width - workspaceW*scale)/2 || 0;
      offsetY = 10;
      resizeCanvas();
      drawWorkspace();
    });

    function resizeCanvas() {
      canvas.width = workspaceW;
      canvas.height = workspaceH;
      canvas.style.width = (workspaceW*scale) + "px";
      canvas.style.height = (workspaceH*scale) + "px";
    }

    function drawWorkspace() {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // Draw all PDF pages
      for(let i=0;i<pdfPages.length;i++) {
        const {img,w,h} = pdfPages[i];
        ctx.drawImage(img,0,pageRects[i].y,w,h);
      }
      // Draw lines
      ctx.strokeStyle = "red";
      ctx.lineWidth = 2;
      ctx.font = "18px sans-serif";
      ctx.fillStyle = "blue";
      let idx = 1;
      for(const l of lines) {
        const rect = pageRects[l.page];
        ctx.beginPath();
        ctx.moveTo(rect.x + l.startX, rect.y + l.startY);
        ctx.lineTo(rect.x + l.endX, rect.y + l.endY);
        ctx.stroke();
        ctx.fillText(idx, rect.x + l.endX + 5, rect.y + l.endY);
        idx++;
      }
    }

    // --- Utility for screen <-> workspace coord
    function screenToWorkspace(x, y) {
      const rect = canvas.getBoundingClientRect();
      const wx = (x - rect.left) / scale - offsetX/scale;
      const wy = (y - rect.top) / scale - offsetY/scale;
      return {x: wx, y: wy};
    }
    function workspaceToScreen(wx, wy) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: wx*scale + offsetX + rect.left,
        y: wy*scale + offsetY + rect.top
      };
    }
    // --- Find page index by workspace y
    function findPageByWorkspace(y) {
      for(let i=0;i<pageRects.length;i++) {
        if(y>=pageRects[i].y && y<pageRects[i].y+pageRects[i].h) return i;
      }
      return null;
    }

    // --- Drawing & Pan/Zoom events (pointer/touch)
    // Mouse
    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      if (e.ctrlKey || e.metaKey) return; // Forbid panning with ctrl/cmd (optional)
      drawing = true;
      const {x, y} = screenToWorkspace(e.clientX, e.clientY);
      drawStart = {x, y};
      drawPage = findPageByWorkspace(y);
    });
    canvas.addEventListener('mousemove', (e) => {
      if (drawing) {
        // Draw preview line if needed
      }
    });
    canvas.addEventListener('mouseup', (e) => {
      if (!drawing) return;
      drawing = false;
      const {x, y} = screenToWorkspace(e.clientX, e.clientY);
      const page = drawPage;
      if (page !== null) {
        const rect = pageRects[page];
        lines.push({
          page,
          startX: drawStart.x - rect.x,
          startY: drawStart.y - rect.y,
          endX: x - rect.x,
          endY: y - rect.y
        });
        drawWorkspace();
      }
    });

    // Touch: distinguish 1 finger (draw), 2 fingers (pan/zoom)
    let touchMode = null; // "draw" or "pan"
    canvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchMode = "draw";
        const {x, y} = screenToWorkspace(e.touches[0].clientX, e.touches[0].clientY);
        drawStart = {x, y};
        drawPage = findPageByWorkspace(y);
        drawing = true;
      } else if (e.touches.length === 2) {
        touchMode = "pan";
        dragging = true;
        lastX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        lastY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        pinchLastDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        pinchLastCenter = { x: lastX, y: lastY };
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      if (touchMode === "draw" && drawing && e.touches.length === 1) {
        // Draw preview if wanted
      } else if (touchMode === "pan" && e.touches.length === 2) {
        e.preventDefault();
        const newX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const newY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        offsetX += (newX - lastX);
        offsetY += (newY - lastY);
        lastX = newX; lastY = newY;

        // Zoom
        const pinchDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        if (pinchLastDist) {
          let zoom = pinchDist / pinchLastDist;
          // Zoom to the center between 2 fingers
          const workspaceBefore = screenToWorkspace(pinchLastCenter.x, pinchLastCenter.y);
          scale *= zoom;
          scale = Math.max(0.2, Math.min(3, scale));
          const workspaceAfter = screenToWorkspace(pinchLastCenter.x, pinchLastCenter.y);
          offsetX += (workspaceAfter.x - workspaceBefore.x) * scale;
          offsetY += (workspaceAfter.y - workspaceBefore.y) * scale;
        }
        pinchLastDist = pinchDist;
        drawWorkspace();
        resizeCanvas();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (touchMode === "draw") {
        if (drawing) {
          drawing = false;
          const touch = e.changedTouches[0];
          const {x, y} = screenToWorkspace(touch.clientX, touch.clientY);
          const page = drawPage;
          if (page !== null) {
            const rect = pageRects[page];
            lines.push({
              page,
              startX: drawStart.x - rect.x,
              startY: drawStart.y - rect.y,
              endX: x - rect.x,
              endY: y - rect.y
            });
            drawWorkspace();
          }
        }
      }
      touchMode = null;
      dragging = false;
      pinchLastDist = null;
      pinchLastCenter = null;
    });

    // Pan/Zoom by mouse (Alt+drag for pan, Ctrl+wheel for zoom)
    let mousePan = false;
    canvas.addEventListener('pointerdown', (e) => {
      if (e.pointerType === "mouse" && e.button === 1) {
        mousePan = true;
        lastX = e.clientX;
        lastY = e.clientY;
      }
    });
    canvas.addEventListener('pointermove', (e) => {
      if (mousePan) {
        offsetX += e.clientX - lastX;
        offsetY += e.clientY - lastY;
        lastX = e.clientX; lastY = e.clientY;
        drawWorkspace();
        resizeCanvas();
      }
    });
    canvas.addEventListener('pointerup', (e) => { mousePan = false; });

    canvas.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const mouse = screenToWorkspace(e.clientX, e.clientY);
        let zoom = e.deltaY < 0 ? 1.08 : 0.92;
        const oldScale = scale;
        scale *= zoom;
        scale = Math.max(0.2, Math.min(3, scale));
        offsetX -= (mouse.x * scale - mouse.x * oldScale);
        offsetY -= (mouse.y * scale - mouse.y * oldScale);
        drawWorkspace();
        resizeCanvas();
      }
    }, { passive: false });

    // --- SAVE PDF ---
    document.getElementById('save-btn').onclick = async function () {
      if (!pdfDoc) return alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î PDF ‡∏Å‡πà‡∏≠‡∏ô');
      const { jsPDF } = window.jspdf;
      let pdf = null;

      // ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏î‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏∏‡∏Å‡∏´‡∏ô‡πâ‡∏≤
      for(let i=1;i<=totalPages;i++) {
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale: 2 });
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = viewport.width;
        tempCanvas.height = viewport.height;
        const tempCtx = tempCanvas.getContext('2d');
        await page.render({ canvasContext: tempCtx, viewport }).promise;
        tempCtx.strokeStyle = "red";
        tempCtx.lineWidth = 2;
        tempCtx.font = "18px sans-serif";
        tempCtx.fillStyle = "blue";
        let idx = 1;
        for(let j=0;j<lines.length;j++) {
          const l = lines[j];
          if (l.page !== i-1) continue;
          tempCtx.beginPath();
          tempCtx.moveTo(l.startX, l.startY);
          tempCtx.lineTo(l.endX, l.endY);
          tempCtx.stroke();
          tempCtx.fillText(idx, l.endX + 5, l.endY);
          idx++;
        }
        const imgData = tempCanvas.toDataURL('image/png');
        if (i === 1) {
          pdf = new jsPDF({
            unit: 'pt',
            format: [viewport.width, viewport.height]
          });
        } else {
          pdf.addPage();
        }
        pdf.addImage(imgData, 'PNG', 0, 0, viewport.width, viewport.height);
      }
      pdf.save('‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏Ç‡∏µ‡∏î‡πÄ‡∏™‡πâ‡∏ô‡πÅ‡∏•‡πâ‡∏ß.pdf');
    };

    // --- Resize on window
    window.addEventListener('resize',()=>{
      if(pdfPages.length>0){
        scale = Math.min(window.innerWidth / workspaceW, window.innerHeight / workspaceH, 1);
        resizeCanvas();
        drawWorkspace();
      }
    });
  </script>
</body>
</html>
